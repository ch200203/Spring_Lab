# JPA - 스프링 부트 활용 개발

- 참고
    - 외래 키가 있는 곳을 연관관계의 주인으로 정해라.
    - 연관관계의 주인은 단순히 외래 키를 누가 관리하냐의 문제이지 비즈니스상 우위에 있다고 주인으로 정하면 안된다.
    - 관리와 유지보수가 어렵고, 추가적으로 별도의 업데이트 쿼리가 발생하는 성능 문제도 있다.
--- 

## 엔티티 클래스 개발
- 실무에서는 가급적 Getter는 열어두고, Setter는 꼭 필요한 경우에만 사용하는 것을 추천
- 이론적으로 Getter, Setter 모두 제공하지 않고, 꼭 필요한 별도의 메서드를 제공하는게 가장 이상적이나, 실무에서 엔티티의 데이터는 조회할 일이 너무 많으므로, Getter의 경우 모두 열어두는 것이 편리하다.
- Setter를 호출하면 데이터가 변한다. Setter를 막 열어두면 가까운 미래에 엔티티에가 도대체 왜 변경되는지 추적하기 점점 힘들어진다.
- 엔티티를 변경할 때는 Setter 대신 변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공해야 한다.

--- 

## 엔티티 설계시 주의할 점

### `ManyToMany`는 실무에서 지양해야 한다.

- `@ManyToMany`는 편리한것 같지만, 중간에 테이블에 컬럼을 추가할 수 없고, 세밀하게 쿼리를 실행하기 어렵기 때문에 실무에서는 사용하기에는 한계가 존재한다.
- 중간에 엔티티를 만들고 `@ManyToOne`, `@OneToMany`로 매핑해서 사용하자.
- 정리하자면, 다대다 매핑을 일대다, 다대일 매핑으로 풀어내서 사용해야 한다.

### 엔티티에는 가급적 Setter 사용을 하지 말아야한다.
Setter가 모두 열려있다면, 변경 포인트가 너무 많아서, 유지보수가 어렵다.
&rarr; 추후 리팩토링으로 Setter를 제거해야한다.

### 연관관계는 지연로등으로 설정
- `fetch`의 즉시로딩(`EAGER`)은 예측이 어렵고, 어떤 SQL이 실행될지 추적하기 어렵다. 특히 JPQL을 실행할 때 N+1 문제가 자주 발생한다.
- 실무에서의 모든 연관관계는 **지연로딩(`LAZY`)**으로 설정해야한다.
- 연관된 엔티티를 함께 DB에서 조회하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
- @XToOne(OneToMany or ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연 로딩으로 설정해야한다.

### 컬렉션은 필드에서 초기화해야 한다.

- 컬렉션은 필드에서 초기화 하는것이 안전하다.
- `null` 문제에 대해서 안전하다.

